import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator
from ypstruct import structure
from gaCore import constraints_violation, prob_Boltzmann, crossover, mutate, apply_bound, roulette_wheel_selection

# COST FUNCTION TO MINIMIZE
def cost(x): 
    return x[0]**2 + x[1]**2

# CONSTRAINTS (form x^2+y^2-a <= 0)
def constraint_functions(x):
    const1 = x[0]**2 - 1
    const2 = x[0] + x[1]**2 + 0.5
    return const1, const2

# PROBLEM DEFINITION
costfunc = cost # define the problem's cost function
nvar = 2 # define number of variables in search space
varmin = [-1, -1] # lower bound of variables
varmax = [1,1] # upper bound of variables
constraints = constraint_functions
constraints_toll = 1e-4

# GA PARAMETERS
maxrep = 5 # maximum number of repetitions
stoprep = 1 # number of same solutions to stop repeating 
digits = 3 # accuracy of digits for a position being the same
maxit = 100 # maximum number of iterations 
stopit = 20 # number of repetitions of same optimum point before breaking
tollcost = 1e-5 # cost difference tollerance for breaking iterations
tollpos = 1e-5 # position difference tollerance for breaking iterations
npop = 50 # size of initial population
pc = 4 # proportion of children to main population
nc = int(np.round(pc*npop/2)*2) # number of children (always even)
beta = 0.3 # Boltzman constant for parent selection probability
gamma = 0.8 # parameter for crossover
mu = 0.1 # mutation threshold
sigma = 0.2 # standard deviation of gene mutation 






# INDIVIDUAL'S TEMPLATE
empty_individual = structure()
empty_individual.position = None
empty_individual.violation = None
empty_individual.valid = True
empty_individual.cost = None
empty_individual.fitness = None


# OUTPUTS' TEMPLATES
fitness = np.zeros([maxit,maxrep])
POS = np.zeros([maxrep,nvar]) # array with best position found at each repetition
FITNESS = np.zeros(maxrep) # array with best fitness found at each repetition
IT = np.zeros([maxit, maxrep]) # array with number of iterations performed at each repetition
n_rep = 0 # number of performed repetitions


for rep in range(maxrep):
    
    # BEST INDIVIDUAL TEMPLATE FOUND AT CURRENT ITERATION
    bestsol = empty_individual.deepcopy() # best individual found at current iteration
    bestsol.fitness = np.inf # set best solution's fitness to be plus infinity

    # ARRAY WITH BEST INDIVIDUAL OF EACH ITERATION FOR CURRENT REPETITION
    bestfitness = np.empty(maxit) # array with best fitness found at each iteration
    bestpos = np.empty([maxit,nvar]) # array with best position found at each iteration



    # INITIALIZE RANDOM POPULATION


#################################### MAYBE CREATE A FUNCTION THAT DOES THIS TO PUT LATER ALSO ####################################

    pop = empty_individual.repeat(npop)
    worst_cost = 0
    for i in range(npop):
        pop[i].position = np.random.uniform(varmin, varmax, nvar) # fill population with npop random individualspop[i].violation = constraints_violation(pop[i].position, constraint_functions)
        pop[i].cost = costfunc(pop[i].position)

        if pop[i].violation > constraints_toll:
            pop[i].valid = False
            if pop[i].cost > worst_cost:
                worst_cost = pop[i].cost
        
    for i in range(npop):
        if pop[i].valid == False:
            pop[i].fitness = worst_cost + pop[i].violation
        else: 
            pop[i].fitness = pop[i].cost
    




            if pop[i].fitness < bestsol.fitness:
                bestsol = pop[i].deepcopy() # calculate the actual best solution of the initialized population
                bestfitness[0] = pop[i]
                bestpos[0] = pop[i].position
                fitness[0,rep] = bestfitness[0]

    # INITIALIZE ITERATION QUITTER
    it_check = 0

    




#################################### ITERATIONS ####################################
    for it in range(1, maxit):
            

        # CHILDREN GENERATION LOOP

        # 1 Calculate parenting probability
        probs = prob_Boltzmann(pop,beta) # probability of each individual to be a parent

        # 2 Initialize population of children
        popc = []

        for _ in range(nc//2):

            # 3 Parents selection (RANDOM)
            #q = np.random.permutation(npop)
            #p1 = pop[q[0]]
               #p2 = pop[q[1]]

            # 3 Parents selection(ROULETTE WHEEL)
            p1 = pop[roulette_wheel_selection(probs)]
            p2 = pop[roulette_wheel_selection(probs)]
        
            # 4 CROSSOVER
            c1, c2 = crossover(p1, p2, gamma)

            # 5 MUTATION
            c1 = mutate(c1, mu, sigma)
            c2 = mutate(c2, mu, sigma)

            # 6 BOUNDARIES
            apply_bound(c1, varmin, varmax)
            apply_bound(c2, varmin, varmax)

            # 7.1 EVALUATE FIRST OFFSPRING
            c1.cost = costfunc(c1.position)
            if c1.cost < bestsol.cost:
                bestsol = c1.deepcopy() # update best individual

            # 7.2 EVALUATE SECOND OFFSPRING
            c2.cost = costfunc(c2.position)
            if c2.cost < bestsol.cost:
                bestsol = c2.deepcopy() # update best individual

            # 8 GENERATE POPULATION OF CHILDREN
            popc.append(c1)
            popc.append(c2)
        
        # MERGE
        pop += popc # merge

        # ELIMINATE DUPLICATES
        positions = np.array([x.position for x in pop])
        positions = np.unique(positions, axis = 0)

        leng = np.shape(positions)[0]
        add = npop+nc-leng

        while add > 0:
            positions = np.concatenate((positions, np.random.uniform(varmin, varmax, (add,nvar))), axis = 0)
            positions = np.unique(positions, axis = 0)
            leng = np.shape(positions)[0]
            add = npop+nc-leng

        new_pop = empty_individual.repeat(leng)
        for a in range(leng):
            new_pop[a].position = positions[a]
            new_pop[a].cost = costfunc(new_pop[a].position)

            
#################################### MODIFY HERE ####################################





            pop = new_pop

        # SORT
        pop = sorted(pop, key=lambda x: x.cost)

           # SELECT
        pop = pop[0:npop]

        bestcost[it] = bestsol.cost # store best cost of iteration in the array
        bestpos[it] = bestsol.position # store best position of iteration in the array
        costs[it,rep] = bestcost[it] 
        IT[it,rep] = it

        # PRINT ITERATION'S INFORMATIONS (# ITERATION AND BEST COST)
        print("Iteration {}:  Best Cost = {}  Best Position = {}".format(it, bestcost[it], bestpos[it]))

        # CHECK FOR OPTIMUM REPETITION 
        diffcost = np.abs(bestcost[it]-bestcost[it-1])
        diffpos = np.abs(np.sum((bestpos[it]-bestpos[it-1])))

        if diffcost < tollcost and diffpos < tollpos:
            it_check += 1
        else: 
            it_check = 0
    
        if it_check == stopit:
            break

    n_rep += 1
    POS[rep] = bestsol.position
    FITNESS[rep] = costfunc(POS[rep])
    n = np.count_nonzero(np.all((np.around(POS[0:rep], decimals = digits) == np.around(bestsol.position, decimals = digits)), axis = 1))

    if n == stoprep:
        break





    
    
       